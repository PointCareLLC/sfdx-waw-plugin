import { core, SfdxCommand, flags } from '@salesforce/command';
import { MetadataInfo, SaveResult } from 'jsforce';
import forge = require('node-forge');
import fs = require('fs');
import helper = require('../../../shared/connectedapp');

// This type doesn't exist in @types/jsforce
interface ConnectedApp extends MetadataInfo {
  oauthConfig: { consumerSecret: string };
}

export default class Create extends SfdxCommand {

  // public static description = 'Create a connected app in your org';

  public static examples = [
    `sfdx waw:connectedapp:create
    `
  ];

  protected static flagsConfig = {
    name: flags.string(
      {
        char: 'n',
        description: 'connected app name',
        required: true
      }),
    label: flags.string(
      {
        char: 'l',
        description: 'connected app label'
      }
    ),
    certificate: flags.boolean(
      {
        char: 'r',
        description: 'create and register a certificate'
      }
    ),
    callbackurl: flags.string(
      {
        char: 'c',
        description: 'callbackUrl (default is "sfdx://success")',
        default: 'sfdx://success'
      }
    ),
    description: flags.string(
      {
        char: 'd',
        description: 'connected app description',
        default: 'generated by waw:connectedapp:create'
      }
    ),
    scopes: flags.string(
      {
        char: 's',
        description: 'scopes separated by commas (defaut: Basic, Api, Web, RefreshToken; valid: Basic, Api, Web, Full, Chatter, CustomApplications, RefreshToken, OpenID, CustomPermissions, Wave, Eclair)',
        default: 'Basic,Api,Web,RefreshToken'
      }
    ),
    contactemail: flags.string(
      {
        char: 'e',
        description: 'connected app contact email'
      }
    )
  };

  // sfdx options
  protected static requiresUsername = true;
  protected static supportsDevhubUsername = false;
  protected static requiresProject = false;

  public async run(): Promise<any> { // tslint:disable-line:no-any

    const connectedAppName = this.flags.name;
    let contactEmail = this.flags.contactemail;

    let connectedAppLabel = this.flags.label;
    if (this.flags.label === null || this.flags.label === undefined) {
      connectedAppLabel = connectedAppName;
    }

    const callbackurl = this.flags.callbackurl;
    const createCerts = this.flags.certificate;
    const appDescription = this.flags.description;
    const appScopes = this.flags.scopes.split(',');

    const conn = this.org.getConnection();
    const certHelper = new helper.ConnectedApp();

    const pki = forge.pki;
    const keys = pki.rsa.generateKeyPair(2048);
    const privKey = forge.pki.privateKeyToPem(keys.privateKey);
    contactEmail = contactEmail || conn.getUsername();

    const generatedConsumerSecret = certHelper.getConsumerSecret();

    let pubKey;

    if (createCerts) {

      const cert = await certHelper.getSelfSignedCertificate(pki, keys);

      pubKey = pki.certificateToPem(cert);

      fs.writeFile('server.key', privKey, (err) => {
        if (err) {
          this.ux.error(err);
          return;
        }
      });

      fs.writeFile('server.crt', pubKey, (err) => {
        if (err) {
          this.ux.error(err);
          return;
        }
      });
    }

    let metadata;

    if (createCerts) {
      metadata = [{
        contactEmail,
        description: appDescription,
        fullName: connectedAppName,
        label: connectedAppLabel,
        oauthConfig: {
          callbackUrl: callbackurl,
          consumerSecret: generatedConsumerSecret,
          certificate: pubKey,
          scopes: appScopes
        }
      }];
    } else {
      metadata = [{
        contactEmail,
        description: appDescription,
        fullName: connectedAppName,
        label: connectedAppLabel,
        oauthConfig: {
          callbackUrl: callbackurl,
          consumerSecret: generatedConsumerSecret,
          scopes: appScopes
        }
      }];
    }

    const createResults = await conn.metadata.create('ConnectedApp', metadata) as SaveResult;

    if (createResults.success) {
      const readResult = await conn.metadata.read('ConnectedApp', connectedAppName) as ConnectedApp;
      // add the consume secret to the output (since it's not returned)
      readResult.oauthConfig.consumerSecret = generatedConsumerSecret;

      this.ux.logJson(readResult);

    } else {
      this.ux.error(createResults);
    }
  }
}
